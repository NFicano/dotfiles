#!/bin/sh
# renew-ssl-cert - Auto Renewal of Let's Encrypt SSL Certificate.

set -o errexit          # Exit on most errors (see the manual)
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
#set -o xtrace          # Trace the execution of the script (debug)
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# shellcheck disable=SC2154
trap 'ret=$?; test $ret -ne 0 && printf "failed\n\n" >&2; exit $ret' EXIT

FQDN="$(hostname).$(nvram get wan_domain)"
MAX_RETRIES=${MAX_RETRIES:-3}
RETRY_INTERVAL=5

silence() {
  "$@" 2> /dev/null > /dev/null;
}

is_nginx_running() {
  ps w | grep -v grep | grep 'nginx' > /dev/null
}

force_kill_nginx() {
  pid=$(ps w | grep -v grep | grep 'nginx' | awk '{print $1}')
  kill $pid
}

grep_iptables() {
  iptables -L $1 --line-numbers | grep -E "$2"
}

flush_http_rules() {
  log "purging all iptable rules from 0.0.0.0 on ports 80 and 443"
  rul=$(grep_iptables INPUT "tcp dpt:(www|https)" | awk '{print $1}' | sort -rg)
  for r in $rul; do
    log "deleted iptable rule $r"
    iptables -D INPUT $r
  done
}

start_nginx() {
  log "starting nginx"
  silence /opt/etc/init.d/S80nginx start
  log "allowing access to tcp ports 80 and 443"
  iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT
  iptables -t filter -A INPUT -p tcp --dport 443 -j ACCEPT
}

stop_nginx() {
  log "stopping nginx"
  silence /opt/etc/init.d/S80nginx stop || true
  sleep 5
  if is_nginx_running; then
    log "failed to stop nginx gracefully - terminating process"
    force_kill_nginx
  fi
  log "dropping access to tcp ports 80 and 443"
  iptables -t filter -A INPUT -p tcp --dport 80 -j DROP
  iptables -t filter -A INPUT -p tcp --dport 443 -j DROP
}

is_http_response_ok() {
  count=1
  url="https://isitdown.site/api/v2/$FQDN"
  while [ $((count)) -le $((MAX_RETRIES)) ]; do
    case "$(curl --silent $url | jq -r '.isitdown')" in
      false)
      log "$FQDN appears to be up";
      return 0
      ;;
      true)
      err "$FQDN appears to be down"
      sleep "$RETRY_INTERVAL"
      count=$((count+1));
      ;;
    esac
  done
  return 1
}

log () {
  timestamp=$(date +"%b %d %H:%M:%S")
  script=$(basename "$0")
  message="$1"; shift
  # shellcheck disable=SC2059
  printf "$timestamp ${script}[$$]: $message\\n" "$@"
  logger -p cron.debug -t $script "$message"
}

err () {
  timestamp=$(date +"%b %d %H:%M:%S")
  script=$(basename "$0")
  message="$1"; shift
  # shellcheck disable=SC2059
  printf "$timestamp ${script}[$$]: $message\\n" "$@"
  logger -p cron.err -t $script "$message"
}

cleanup() {
  stop_nginx
  flush_http_rules
}

copy() {
  log "copying $1 -> $2"
  cp $1 $2
}

renew_cert() {
  log "renewing ssl certificate"
  cd /opt/etc/nginx || exit 1
  # note: add --force when debugging
  bash ./dehydrated --domain $FQDN --cron

  copy "/opt/etc/nginx/certs/$FQDN/cert.pem" /etc/cert.pem
  copy "/opt/etc/nginx/certs/$FQDN/privkey.pem" /etc/key.pem
  sed -i "/END CERTIFICATE/q" /etc/cert.pem

  log "archiving/gzipping certs"
  tar -C / -cf /tmp/cert.tar etc/cert.pem etc/key.pem
  gzip -f /tmp/cert.tar

  log "writing to certs to nvram"
  https_crt_file="$(openssl enc -base64 < /tmp/cert.tar.gz | tr -d '\n')"
  nvram set $https_crt_file

  log "commiting to nvram"
  nvram commit

  log "restarting httpd"
  service httpd restart
}

main() {
  log "renewing letsencrypt ssl certificate"
  cleanup
  start_nginx
  if is_http_response_ok; then
    renew_cert
  else
    err "unable to get an http response"
    cleanup
  fi
}

main

trap cleanup EXIT
